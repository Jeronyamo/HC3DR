#version 460
#extension GL_GOOGLE_include_directive : require

#include "common_pinhole_gpu.h"

layout(binding = 0, set = 0) buffer data0 { float in_color[]; }; //
layout(binding = 1, set = 0) buffer data1 { float out_color[]; }; //
layout(binding = 2, set = 0) buffer data2 { float m_cie_z[]; }; //
layout(binding = 3, set = 0) buffer data3 { float m_cie_y[]; }; //
layout(binding = 4, set = 0) buffer data4 { float m_cie_x[]; }; //
layout(binding = 5, set = 0) buffer data5 { float m_storedWaves[]; }; //
layout(binding = 6, set = 0) buffer dataUBO { CamPinHole_PINHOLE_GPU_UBO_Data ubo; };

vec3 SpectrumToXYZ_m_cie_x_m_cie_y_m_cie_z(vec4 spec, vec4 lambda, float lambda_min, float lambda_max, uint a_CIE_XOffset, uint a_CIE_YOffset, uint a_CIE_ZOffset) {
  const float pdf = 1.0f / (lambda_max - lambda_min);
  const float CIE_Y_integral = 106.856895f;
  const uint nCIESamples = 471;

  //TODO: fix
  for (uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
    spec[int(i)] = (pdf != 0) ? spec[int(i)] / pdf : 0.0f;

  //float4 X = SampleCIE(lambda, a_CIE_X, lambda_min, lambda_max);
  //float4 Y = SampleCIE(lambda, a_CIE_Y, lambda_min, lambda_max);
  //float4 Z = SampleCIE(lambda, a_CIE_Z, lambda_min, lambda_max);
  vec4 X,  Y,  Z; 
  for (uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i) 
  {
    uint offset = uint32_t(float(floor(lambda[int(i)] + 0.5f)) - lambda_min);
  
    if (offset >= nCIESamples)
      X[int(i)] = 0;
    else
      X[int(i)] = m_cie_x[offset + a_CIE_XOffset];
  
    if (offset >= nCIESamples)
      Y[int(i)] = 0;
    else
      Y[int(i)] = m_cie_y[offset + a_CIE_YOffset];
  
    if (offset >= nCIESamples)
      Z[int(i)] = 0;
    else
      Z[int(i)] = m_cie_z[offset + a_CIE_ZOffset];
  }

  for (uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    X[int(i)] *= spec[int(i)];
    Y[int(i)] *= spec[int(i)];
    Z[int(i)] *= spec[int(i)];
  }

  float x = SpectrumAverage(X) / CIE_Y_integral;
  float y = SpectrumAverage(Y) / CIE_Y_integral;
  float z = SpectrumAverage(Z) / CIE_Y_integral;

  return vec3(x,y,z);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  int subPassId;
  int in_blockSize; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;


void main()
{
  bool runThisThread = true;
  ///////////////////////////////////////////////////////////////// prolog
  const int tid = int(gl_GlobalInvocationID[0]); 
  if(tid >= kgenArgs.in_blockSize + 0)
    runThisThread = false;
    ///////////////////////////////////////////////////////////////// prolog
  if(runThisThread)
  {
  
    const int x = (tid + kgenArgs.subPassId*kgenArgs.in_blockSize) % ubo.m_width;  // pitch-linear layout
    const int y = (tid + kgenArgs.subPassId*kgenArgs.in_blockSize) / ubo.m_height; // subPas is just a uniform slitting of image along the lines

    //float4 color = float4(in_color[4*tid+0], in_color[4*tid+1], in_color[4*tid+2], in_color[4*tid+3]); // always float4
    vec4 color;   
    if(ubo.m_spectral_mode != 0)
    {
      float data = in_color[tid];
      color = vec4(data,data,data,data);
    }
    else
      color = vec4(in_color[4*tid+0],in_color[4*tid+1],in_color[4*tid+2],in_color[4*tid+3]);

    if(ubo.m_spectral_mode != 0) // TODO: spectral framebuffer
    {
      const vec4 wavelengths = vec4(m_storedWaves[tid]);
                                  
      const vec3 xyz = SpectrumToXYZ_m_cie_x_m_cie_y_m_cie_z(color, wavelengths, CAM_LAMBDA_MIN, CAM_LAMBDA_MAX, 0, 0, 0);
      color = vec4(XYZToRGB(xyz), 1.0f);
    }

    out_color[(y*ubo.m_width+x)*4+0] += color[0];  // R
    out_color[(y*ubo.m_width+x)*4+1] += color[1];  // G
    out_color[(y*ubo.m_width+x)*4+2] += color[2];  // B
    //out_color[(y*m_width+x)*4+3] += color[3];// A
  
  }
}

