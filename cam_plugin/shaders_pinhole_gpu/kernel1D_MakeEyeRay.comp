#version 460
#extension GL_GOOGLE_include_directive : require

#include "common_pinhole_gpu.h"

layout(binding = 0, set = 0) buffer data0 { RayPosAndW out_rayPosAndNear4f[]; }; //
layout(binding = 1, set = 0) buffer data1 { RayDirAndT out_rayDirAndFar4f[]; }; //
layout(binding = 2, set = 0) buffer data2 { float m_storedWaves[]; }; //
layout(binding = 3, set = 0) buffer data3 { RandomGenT m_randomGens[]; }; //
layout(binding = 4, set = 0) buffer dataUBO { CamPinHole_PINHOLE_GPU_UBO_Data ubo; };

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  int subPassId;
  int in_blockSize; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;


void main()
{
  bool runThisThread = true;
  ///////////////////////////////////////////////////////////////// prolog
  const int tid = int(gl_GlobalInvocationID[0]); 
  if(tid >= kgenArgs.in_blockSize + 0)
    runThisThread = false;
    ///////////////////////////////////////////////////////////////// prolog
  if(runThisThread)
  {
  
    const int x = (tid + kgenArgs.subPassId*kgenArgs.in_blockSize) % ubo.m_width;  // pitch-linear layout
    const int y = (tid + kgenArgs.subPassId*kgenArgs.in_blockSize) / ubo.m_height; // subPas is just a uniform slitting of image along the lines
    
    //if(x == 512 && y == 1023-100) // to debug target pixel
    //{
    //  int a = 2;
    //}

    vec3 rayDir = EyeRayDirNormalized(float(float(x)+0.5f)/float(ubo.m_width), float(float(y)+0.5f)/float(ubo.m_height), ubo.m_projInv);
    vec3 rayPos = vec3(0,0,0);
  
    vec4 wavelengths = vec4(0,0,0,0);
    if(ubo.m_spectral_mode != 0)
    {
      RandomGenT genLocal = m_randomGens[tid];
      float u           = rndFloat1_Pseudo(genLocal);
      wavelengths       = SampleWavelengths(u, CAM_LAMBDA_MIN, CAM_LAMBDA_MAX);
      m_randomGens[tid] = genLocal;
    }

    RayPosAndW p1;
    RayDirAndT p2;

    p1.origin[0] = rayPos[0];
    p1.origin[1] = rayPos[1];
    p1.origin[2] = rayPos[2];
    p1.wave      = wavelengths.x;

    p2.direction[0] = rayDir[0];
    p2.direction[1] = rayDir[1];
    p2.direction[2] = rayDir[2];
    p2.time         = 0.0f;
  
    out_rayPosAndNear4f[tid] = p1;
    out_rayDirAndFar4f [tid] = p2;
    m_storedWaves      [tid] = wavelengths.x; // just remember waves in our buffer for camera
  
  }
}

