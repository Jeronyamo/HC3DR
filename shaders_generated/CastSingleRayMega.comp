#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : require

#include "common_generated.h"
layout (constant_id = 1) const int KSPEC_MAT_TYPE_GLTF = 1;
layout (constant_id = 2) const int KSPEC_MAT_TYPE_GLASS = 2;
layout (constant_id = 3) const int KSPEC_MAT_TYPE_CONDUCTOR = 3;
layout (constant_id = 4) const int KSPEC_MAT_TYPE_DIFFUSE = 4;
layout (constant_id = 5) const int KSPEC_MAT_TYPE_PLASTIC = 5;
layout (constant_id = 6) const int KSPEC_SPECTRAL_RENDERING = 6;
layout (constant_id = 7) const int KSPEC_MAT_TYPE_BLEND = 7;
layout (constant_id = 8) const int KSPEC_BLEND_STACK_SIZE = 8;
layout (constant_id = 9) const int KSPEC_BUMP_MAPPING = 9;

layout(binding = 0, set = 0) buffer data0 { uint out_color[]; }; //
layout(binding = 1, set = 0) buffer data1 { int m_allRemapListsOffsets[]; }; //
layout(binding = 2, set = 0) buffer data2 { LightSource m_lights[]; }; //
layout(binding = 3, set = 0) buffer data3 { int m_allRemapLists[]; }; //
layout(binding = 4, set = 0) buffer data4 { float m_precomp_coat_transmittance[]; }; //
layout(binding = 5, set = 0) buffer data5 { float m_wavelengths[]; }; //
layout(binding = 6, set = 0) buffer data6 { Material m_materials[]; }; //
layout(binding = 7, set = 0) buffer data7 { int m_remapInst[]; }; //
layout(binding = 8, set = 0) buffer data8 { float m_spec_values[]; }; //
layout(binding = 9, set = 0) buffer data9 { uint m_packedXY[]; }; //
layout(binding = 10, set = 0) uniform sampler2D m_textures[]; //
layout(binding = 11, set = 0) buffer data11 { uvec2 m_spec_offset_sz[]; }; //
layout(binding = 12, set = 0) uniform accelerationStructureEXT m_pAccelStruct;
layout(binding = 13, set = 0) buffer data13 { uint m_matIdOffsets[]; }; //
layout(binding = 14, set = 0) buffer data14 { uint m_matIdByPrimId[]; }; //
layout(binding = 15, set = 0) buffer dataUBO { Integrator_Generated_UBO_Data ubo; };

void diffuseEval_m_materials(uint a_materialsOffset, vec4 a_reflSpec, vec3 l, vec3 v, vec3 n, vec2 tc, vec4 color, inout BsdfEval res) {
  const uint             cflags = floatBitsToUint(m_materials[0 + a_materialsOffset].data[UINT_CFLAGS]);
 
  float lambertVal       = lambertEvalBSDF(l, v, n);
  const float lambertPdf = lambertEvalPDF (l, v, n);

  if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
    lambertVal *= orennayarFunc(l, v, n, m_materials[0 + a_materialsOffset].data[DIFFUSE_ROUGHNESS]);

  res.val = lambertVal * a_reflSpec; 
  res.pdf = lambertPdf; 
}

void conductorRoughEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfEval pRes) {
  // const uint cflags = as_uint(a_materials[0].data[UINT_CFLAGS]);

  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_U], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_V], alpha_tex.y));

  vec3 nx,  ny, nz = n;
  CoordinateSystemV2(nz, nx, ny);

  // v = (-1.0f) * v;
  const vec3 wo = vec3(dot(v, nx),dot(v, ny),dot(v, nz));
  const vec3 wi = vec3(dot(l, nx),dot(l, ny),dot(l, nz));

  if(wo.z * wi.z < 0.0f)
    return;

  vec3 wm = wo + wi;
  if (dot(wm, wm) == 0)
      return;

  wm = normalize(wm);
  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = conductorRoughEvalInternal(wo, wi, wm, alpha, make_complex(etaSpec[int(i)],kSpec[int(i)]));
  }

  pRes.val = val;

  wm        = FaceForward(wm, vec3(0.0f,0.0f,1.0f));
  pRes.pdf = trPDF(wo, wm, alpha) / (4.0f * abs(dot(wo, wm)));
}

void gltfEval_m_materials(uint a_materialsOffset, vec3 l, vec3 v, vec3 n, vec2 tc, vec4 color, inout BsdfEval res) {
  const uint   cflags     = floatBitsToUint(m_materials[0 + a_materialsOffset].data[UINT_CFLAGS]);
  const vec4 specular = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_METAL];
  const vec4 coat = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_COAT];
  const float  roughness  = clamp(1.0f - m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_GLOSINESS], 0.0f, 1.0f);
        float  alpha      = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ALPHA];
  const float  fresnelIOR = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_IOR];

  if(cflags == GLTF_COMPONENT_METAL) // assume only GGX-based metal
    alpha = 1.0f;
      
  float ggxVal, ggxPdf, VdotH; 
  if(roughness != 0.0f) // perfect specular reflection in coating layer
  {
    ggxVal = ggxEvalBSDF(l, v, n, roughness);
    ggxPdf = ggxEvalPDF (l, v, n, roughness);
    VdotH  = dot(v,normalize(v + l));
  }
  else
  {
    ggxVal = 0.0f;
    ggxPdf = 0.0f;
    VdotH  = dot(v,n);
  }

  float lambertVal       = lambertEvalBSDF(l, v, n);
  const float lambertPdf = lambertEvalPDF (l, v, n);
  float f_i              = 1.0f;
  float prob_diffuse     = 1.0f;
  float prob_specular    = 0.0f;
  float coeffLambertPdf  = 1.0f;

  if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
    lambertVal *= orennayarFunc(l, v, n, m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ROUGH_ORENNAYAR]);
      
  if((cflags & GLTF_COMPONENT_COAT) != 0 && (cflags & GLTF_COMPONENT_LAMBERT) != 0) // Plastic, account for retroreflection between surface and coating layer
  {
    f_i                                    = FrDielectricPBRT(abs(dot(v,n)), 1.0f, fresnelIOR);
    const float f_o                        = FrDielectricPBRT(abs(dot(l,n)), 1.0f, fresnelIOR);  
    const float m_fdr_int                  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_FDR_INT];
    const float coeff                      = (1.f - f_i) * (1.f - f_o) / (fresnelIOR*fresnelIOR*(1.f - m_fdr_int));
    lambertVal                            *= coeff;
    coeffLambertPdf                        = coeff; 
    const float m_specular_sampling_weight = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_SSW];
    prob_specular                          = f_i * m_specular_sampling_weight;
    prob_diffuse                           = (1.f - f_i) * (1.f - m_specular_sampling_weight);
    
    if(prob_diffuse != 0.0f && prob_specular != 0.0f)
      prob_diffuse = prob_diffuse / (prob_specular + prob_diffuse);
    else
    {
      prob_diffuse  = 1.0f;
      prob_specular = 0.0f;
    }
  }

  const vec4 fConductor = hydraFresnelCond(specular, VdotH, fresnelIOR, roughness); // (1) eval metal component      
  const vec4 specularColor = ggxVal*fConductor;                                        // eval metal specular component
      
  float  dielectricPdf = lambertPdf * coeffLambertPdf; 
  if((cflags & GLTF_COMPONENT_COAT) != 0)
    dielectricPdf += 2.0f * ggxPdf * f_i; 
                                
  const vec4 dielectricVal = lambertVal * color + ggxVal * coat * f_i;

  res.val = alpha * specularColor + (1.0f - alpha) * dielectricVal; // (3) accumulate final color and pdf
  res.pdf = alpha * ggxPdf        + (1.0f - alpha) * dielectricPdf; // (3) accumulate final color and pdf
}

void plasticSampleAndEval_m_materials_m_precomp_coat_transmittance(uint a_materialsOffset, vec4 a_reflSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes, uint transmittanceOffset) {
  // const uint  cflags    = as_uint(a_materials[0].data[UINT_CFLAGS]);
  const float alpha     = m_materials[0 + a_materialsOffset].data[PLASTIC_ROUGHNESS];
  const float eta       = m_materials[0 + a_materialsOffset].data[PLASTIC_IOR_RATIO];
  const float spec_weight = m_materials[0 + a_materialsOffset].data[PLASTIC_SPEC_SAMPLE_WEIGHT];
  const uint  nonlinear   = floatBitsToUint(m_materials[0 + a_materialsOffset].data[PLASTIC_NONLINEAR]);
  const float internal_refl = m_materials[0 + a_materialsOffset].data[PLASTIC_PRECOMP_REFLECTANCE];
  const vec2 alpha2 = vec2(alpha,alpha);

  vec3 s = n;
  vec3 t = n;
  CoordinateSystemV2(n, s, t);
  
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  if(wi.z <= 0)
    return;

  const float cos_theta_i = max(wi.z, EPSILON_32);

  // float t_i = lerp_gather(transmittance, cos_theta_i, MI_ROUGH_TRANSMITTANCE_RES);
  float t_i = 0.0f;
  {
    float x = cos_theta_i;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_i = mix(v0, v1, x - float(index));
  }

  float prob_specular = (1.f - t_i) * spec_weight;
  float prob_diffuse  = t_i * (1.f - spec_weight);

  if(prob_diffuse != 0.0f && prob_specular != 0.0f)
  {
    prob_specular = prob_specular / (prob_specular + prob_diffuse);
    prob_diffuse  = 1.f - prob_specular;
  }
  else
  {
    prob_diffuse  = 1.0f;
    prob_specular = 0.0f;
  }

  const bool sample_specular = rands.z < prob_specular;
  const bool sample_diffuse = !sample_specular;

  vec3 wo = vec3(0.0f,0.0f,0.0f);
  if(sample_specular)
  {
    const vec3 wm = (sample_visible_normal(wi, vec2(rands.x,rands.y), alpha2)).xyz;
    wo = reflect((-1.0f) * wi, wm);
  }

  if(sample_diffuse)
  {
    wo = square_to_cosine_hemisphere(vec2(rands.x,rands.y));
  }

  if(cos_theta_i * wo.z <= 0)
  {
    return;
  }

  const float cos_theta_o = max(wo.z, EPSILON_32);

  vec3 H = normalize(wo + wi);
  float  D = eval_microfacet(H, alpha2, 1);

  float pdf = D * smith_g1(wi, H, alpha2) / (4.f * cos_theta_i);
  pdf *= prob_specular;
  pdf += prob_diffuse * INV_PI * cos_theta_o;

  const float F = FrDielectric(dot(wi, H), eta); 
  float G = microfacet_G(wi, wo, H, alpha2);
  float val = F * D * G / (4.f * cos_theta_i * cos_theta_o);

  // float t_o = lerp_gather(transmittance, cos_theta_o, MI_ROUGH_TRANSMITTANCE_RES); 
  float t_o = 0.0f;
  {
    float x = cos_theta_o;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_o = mix(v0, v1, x - float(index));
  }

  vec4 diffuse = a_reflSpec / (1.f - (nonlinear > 0 ? (a_reflSpec * internal_refl) : vec4(internal_refl)));
  const float inv_eta_2 = 1.f / (eta * eta);

  pRes.dir   = normalize(wo.x * s + wo.y * t + wo.z * n);
  pRes.val   = vec4(val) + diffuse * (INV_PI * inv_eta_2 * /*cos_theta_o **/ t_i * t_o );
  pRes.pdf   = pdf;
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
}

vec4 SampleSpectrum_m_wavelengths_m_spec_values(uint a_spec_wavelengthsOffset, uint a_spec_valuesOffset, vec4 a_wavelengths, uint a_sz) {
  vec4 sampleSpec = vec4(0,0,0,0);
  const uint spectralSamples = uint(16 / 4); 
  for(uint i = 0; i < spectralSamples; ++i)
  {
    if (a_sz == 0 || a_wavelengths[int(i)] < m_wavelengths[0 + a_spec_wavelengthsOffset] || a_wavelengths[int(i)] > m_wavelengths[a_sz - 1 + a_spec_wavelengthsOffset])
    {
      sampleSpec[int(i)] = 0.0f;
    }
    else
    {
      int last = int(a_sz) - 2, first = 1;
      while (last > 0) 
      {
        int half = last >> 1, 
        middle = first + half;
        bool predResult = m_wavelengths[middle + a_spec_wavelengthsOffset] <= a_wavelengths[int(i)];
        first = predResult ? int(middle + 1) : first;
        last = predResult ? last - int(half + 1) : int(half);
      }
      int o = clamp(int(first - 1), 0, int(a_sz - 2));

      float t = (a_wavelengths[int(i)] - m_wavelengths[o + a_spec_wavelengthsOffset]) / (m_wavelengths[o + 1 + a_spec_wavelengthsOffset] - m_wavelengths[o + a_spec_wavelengthsOffset]);
      sampleSpec[int(i)] =  mix(m_spec_values[o + a_spec_valuesOffset], m_spec_values[o + 1 + a_spec_valuesOffset], t);
    } 
  }
  return sampleSpec;
}

LightSample pointLightSampleRev_m_lights(uint a_pLightOffset) {
  LightSample res;
  res.pos    = m_lights[0 + a_pLightOffset].pos.xyz;
  res.norm   = m_lights[0 + a_pLightOffset].norm.xyz;
  res.isOmni = (m_lights[0 + a_pLightOffset].distType == LIGHT_DIST_OMNI);
  return res;
}

void glassEval_m_materials(uint a_materialsOffset, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 color, inout BsdfEval res) {
  // because we don't want to sample this material with shadow rays
  res.val   = vec4(0.0f);
  res.pdf   = 0.0f;
}

LightSample areaLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands) {
  vec2 sampleOff = 2.0f * (vec2(-0.5f,-0.5f) + rands) * m_lights[0 + a_pLightOffset].size;  // PLEASE! use 'a_pLight[0].' for a while ... , not a_pLight-> and not *(a_pLight[0])
  if(m_lights[0 + a_pLightOffset].geomType == LIGHT_GEOM_DISC)
  {
    const float offsetX = rands.x * 2.0f - 1.0f;
    const float offsetY = rands.y * 2.0f - 1.0f;
    sampleOff = MapSamplesToDisc(vec2(offsetX,offsetY))*m_lights[0 + a_pLightOffset].size.x; 
  }
  const vec3 samplePos = mul3x3(m_lights[0 + a_pLightOffset].matrix, vec3(sampleOff.x,0.0f,sampleOff.y)) + m_lights[0 + a_pLightOffset].pos.xyz + epsilonOfPos(m_lights[0 + a_pLightOffset].pos.xyz) * m_lights[0 + a_pLightOffset].norm.xyz;
  LightSample res;
  res.pos    = samplePos;
  res.norm   = m_lights[0 + a_pLightOffset].norm.xyz;
  res.isOmni = false;
  return res;
}

LightSample directLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands, vec3 illuminationPoint) {
  const vec3 norm = m_lights[0 + a_pLightOffset].norm.xyz;
  LightSample res;
  res.pos    = illuminationPoint - norm*100000.0f;
  res.norm   = norm;
  res.isOmni = false;
  return res;
}

LightSample sphereLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands) {
  const float theta = 2.0f * M_PI * rands.x;
  const float phi   = acos(1.0f - 2.0f * rands.y);
  const float x     = sin(phi) * cos(theta);
  const float y     = sin(phi) * sin(theta);
  const float z     = cos(phi);
  const vec3 lcenter = m_lights[0 + a_pLightOffset].pos.xyz;
  const float  lradius   = m_lights[0 + a_pLightOffset].size.x;
  const vec3 samplePos = lcenter + (lradius*1.000001f)*vec3(x, y, z);
  LightSample res;
  res.pos  = samplePos;
  res.norm = normalize(samplePos - lcenter);
  return res;
}

void gltfSampleAndEval_m_materials(uint a_materialsOffset, vec4 rands, vec3 v, vec3 n, vec2 tc, vec4 color, inout BsdfSample pRes) {
  // PLEASE! use 'a_materials[0].' for a while ... , not a_materials-> and not *(a_materials).
  const uint   cflags   = floatBitsToUint(m_materials[0 + a_materialsOffset].data[UINT_CFLAGS]);
  const vec4 specular = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_METAL]; 
  const vec4 coat = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_COAT];  
  const float  roughness  = clamp(1.0f - m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_GLOSINESS], 0.0f, 1.0f);   
  float        alpha      = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ALPHA];                 
  const float  fresnelIOR = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_IOR];
  
  if(cflags == GLTF_COMPONENT_METAL) // assume only GGX-based metal component set
    alpha = 1.0f;

  vec3 ggxDir;
  float  ggxPdf; 
  float  ggxVal;

  if(roughness == 0.0f) // perfect specular reflection in coating or metal layer
  {
    const vec3 pefReflDir = reflect((-1.0f) * v, n);
    const float cosThetaOut = dot(pefReflDir, n);
    ggxDir                  = pefReflDir;
    ggxVal                  = (cosThetaOut <= 1e-6f) ? 0.0f : (1.0f/max(cosThetaOut, 1e-6f));  // BSDF is multiplied (outside) by cosThetaOut. For mirrors this shouldn't be done, so we pre-divide here instead.
    ggxPdf                  = 1.0f;
  }
  else
  {
    ggxDir                  = ggxSample(vec2(rands.x,rands.y), v, n, roughness);
    ggxPdf                  = ggxEvalPDF (ggxDir, v, n, roughness); 
    ggxVal                  = ggxEvalBSDF(ggxDir, v, n, roughness);
  }

  const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
  const float  lambertPdf   = lambertEvalPDF(lambertDir, v, n);
  const float  lambertVal   = lambertEvalBSDF(lambertDir, v, n);

  // (1) select between metal and dielectric via rands.z
  //
  float pdfSelect = 1.0f;
  if(rands.z < alpha) // select metall
  {
    pdfSelect         *= alpha;
    const float  VdotH = dot(v,normalize(v + ggxDir));
    pRes.dir          = ggxDir;
    pRes.val          = ggxVal * alpha * hydraFresnelCond(specular, VdotH, fresnelIOR, roughness); //TODO: disable fresnel here for mirrors
    pRes.pdf          = ggxPdf;
    pRes.flags        = (roughness == 0.0f) ? RAY_EVENT_S : RAY_FLAG_HAS_NON_SPEC;
  }
  else                // select dielectric
  {
    pdfSelect *= 1.0f - alpha;
    
    // (2) now select between specular and diffise via rands.w
    //
    const float f_i = FrDielectricPBRT(abs(dot(v,n)), 1.0f, fresnelIOR); 
    const float m_specular_sampling_weight = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_SSW];
    
    float prob_specular = f_i * m_specular_sampling_weight;
    float prob_diffuse  = (1.0f - f_i) * (1.0f - m_specular_sampling_weight);
    if(prob_diffuse != 0.0f && prob_specular != 0.0f)
    {
      prob_specular = prob_specular / (prob_specular + prob_diffuse);
      prob_diffuse  = 1.f - prob_specular;
    }
    else
    {
      prob_diffuse  = 1.0f;
      prob_specular = 0.0f;
    }
    float choicePdf = ((cflags & GLTF_COMPONENT_COAT) == 0) ? 0.0f : prob_specular; // if don't have coal layer, never select it
    if(rands.w < prob_specular) // specular
    {
      pdfSelect      *= choicePdf;
      pRes.dir       = ggxDir;
      pRes.val       = ggxVal*coat*(1.0f - alpha)*f_i;
      pRes.pdf       = ggxPdf;
      pRes.flags     = (roughness == 0.0f) ? RAY_EVENT_S : RAY_FLAG_HAS_NON_SPEC;
    } 
    else
    {
      pdfSelect      *= (1.0f-choicePdf); // lambert
      pRes.dir       = lambertDir;
      pRes.val       = lambertVal * color * (1.0f - alpha);
      pRes.pdf       = lambertPdf;
      pRes.flags     = RAY_FLAG_HAS_NON_SPEC;
            
      if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
        pRes.val *= orennayarFunc(lambertDir, (-1.0f) * v, n, m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ROUGH_ORENNAYAR]);
            
      if((cflags & GLTF_COMPONENT_COAT) != 0 && (cflags & GLTF_COMPONENT_LAMBERT) != 0) // Plastic, account for retroreflection between surface and coating layer
      {
        const float m_fdr_int = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_FDR_INT];
        const float f_o       = FrDielectricPBRT(abs(dot(lambertDir, n)), 1.0f, fresnelIOR);
        pRes.val          *= (1.0f - f_i) * (1.0f - f_o) / (fresnelIOR * fresnelIOR * (1.0f - m_fdr_int));
      }
    }
  }   
  pRes.pdf *= pdfSelect;
}

void glassSampleAndEval_m_materials(uint a_materialsOffset, const vec4 a_rands, const vec3 a_viewDir, const vec3 a_normal, const vec2 a_tc, inout BsdfSample a_pRes, inout MisData a_misPrev) {
  // PLEASE! use 'a_materials[0].' for a while ... , not a_materials-> and not *(a_materials).
  const vec4 colorReflect = m_materials[0 + a_materialsOffset].colors[GLASS_COLOR_REFLECT];   
  const vec4 colorTransp = m_materials[0 + a_materialsOffset].colors[GLASS_COLOR_TRANSP];
  const float  ior                  = m_materials[0 + a_materialsOffset].data[GLASS_FLOAT_IOR];

  const vec3 rayDir = (-1.0f) * a_viewDir;
  float relativeIor   = ior / a_misPrev.ior;

  if ((a_pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) // hit the reverse side of the polygon from the volume
  {
    if (a_misPrev.ior == ior) // in the previous hit there was material with a equal IOR
      relativeIor = 1.0f / ior;
  }

  const float fresnel = fresnel2(a_viewDir, a_normal, relativeIor);

  vec3 dir;

  if (a_rands.w < fresnel) // reflection
  {
    dir            = reflect2(rayDir, a_normal);
    a_pRes.val    =  colorReflect;
    a_pRes.flags |= RAY_EVENT_S;
  }
  else
  {
    dir            = refract2(rayDir, a_normal, relativeIor);
    a_pRes.val    = colorTransp;
    a_misPrev.ior = ior;
    a_pRes.flags |= (RAY_EVENT_S | RAY_EVENT_T);
  }

  const float cosThetaOut = abs(dot(dir, a_normal));
  
  a_pRes.val      /= max(cosThetaOut, 1e-6f);// BSDF is multiplied (outside) by cosThetaOut. For mirrors this shouldn't be done, so we pre-divide here instead.
  a_pRes.dir       = dir;
  a_pRes.pdf       = 1.0f;
}

void plasticEval_m_materials_m_precomp_coat_transmittance(uint a_materialsOffset, vec4 a_reflSpec, vec3 l, vec3 v, vec3 n, vec2 tc, inout BsdfEval pRes, uint transmittanceOffset) {
  // const uint  cflags    = as_uint(a_materials[0].data[UINT_CFLAGS]);
  const float alpha     = m_materials[0 + a_materialsOffset].data[PLASTIC_ROUGHNESS];
  const float eta       = m_materials[0 + a_materialsOffset].data[PLASTIC_IOR_RATIO];
  // const uint  precomp_id  = as_uint(a_materials[0].data[PLASTIC_PRECOMP_ID]);
  const float spec_weight = m_materials[0 + a_materialsOffset].data[PLASTIC_SPEC_SAMPLE_WEIGHT];
  const uint  nonlinear   = floatBitsToUint(m_materials[0 + a_materialsOffset].data[PLASTIC_NONLINEAR]);
  const float internal_refl = m_materials[0 + a_materialsOffset].data[PLASTIC_PRECOMP_REFLECTANCE];

  const vec2 alpha2 = vec2(alpha,alpha);
  
  vec3 s = n;
  vec3 t = n;
  CoordinateSystemV2(n, s, t);
  
  const vec3 wo = vec3(dot(l, s),dot(l, t),dot(l, n));
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  if(wi.z * wo.z <= 0)
  {
    return;
  }
  const float cos_theta_i = max(wi.z, EPSILON_32);
  const float cos_theta_o = max(wo.z, EPSILON_32);

  // float t_i = lerp_gather(transmittance, cos_theta_i, MI_ROUGH_TRANSMITTANCE_RES);
  float t_i = 0.0f;
  {
    float x = cos_theta_i;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_i = mix(v0, v1, x - float(index));
  }

  float prob_specular = (1.f - t_i) * spec_weight;
  float prob_diffuse  = t_i * (1.f - spec_weight);

  if(prob_diffuse != 0.0f && prob_specular != 0.0f)
  {
    prob_specular = prob_specular / (prob_specular + prob_diffuse);
    prob_diffuse  = 1.f - prob_specular;
  }
  else
  {
    prob_diffuse  = 1.0f;
    prob_specular = 0.0f;
  }

 
  vec3 H = normalize(wo + wi);
  float  D = eval_microfacet(H, alpha2, 1);
  float smith_g1_wi = smith_g1(wi, H, alpha2);

  float pdf = D * smith_g1_wi / (4.f * cos_theta_i);
  pdf *= prob_specular;
  pdf += prob_diffuse * INV_PI * cos_theta_o;


  const float F = FrDielectric(dot(wi, H), eta); 
  float G = smith_g1(wo, H, alpha2) * smith_g1_wi;
  float val = F * D * G / (4.f * cos_theta_i * cos_theta_o);

  // float t_o = lerp_gather(transmittance, cos_theta_o, MI_ROUGH_TRANSMITTANCE_RES); 
  float t_o = 0.0f;
  {
    float x = cos_theta_o;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_o = mix(v0, v1, x - float(index));
  }

  vec4 diffuse = a_reflSpec / (1.f - (nonlinear > 0 ? (a_reflSpec * internal_refl) : vec4(internal_refl)));
  const float inv_eta_2 = 1.f / (eta * eta);

  pRes.val   = vec4(val) + diffuse * (INV_PI * inv_eta_2 * /*cos_theta_o **/ t_i * t_o );
  pRes.pdf   = pdf;
}

void diffuseSampleAndEval_m_materials(uint a_materialsOffset, vec4 a_reflSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, vec4 color, inout BsdfSample pRes) {
  const uint   cflags     = floatBitsToUint(m_materials[0 + a_materialsOffset].data[UINT_CFLAGS]);
  const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
  const float  lambertPdf = lambertEvalPDF(lambertDir, v, n);
  const float  lambertVal = lambertEvalBSDF(lambertDir, v, n);

  pRes.dir   = lambertDir;
  pRes.val   = lambertVal * a_reflSpec;
  pRes.pdf   = lambertPdf;
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
        
  if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
    pRes.val *= orennayarFunc(lambertDir, (-1.0f) * v, n, m_materials[0 + a_materialsOffset].data[DIFFUSE_ROUGHNESS]);
            
}

void conductorSmoothSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes) {
  // const uint cflags = as_uint(a_materials[0].data[UINT_CFLAGS]);

  const vec3 pefReflDir = reflect((-1.0f)*v, n);
  const float cosThetaOut = dot(pefReflDir, n);
  vec3 dir = pefReflDir;
  float  pdf              = 1.0f;
  
  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = FrComplexConductor(cosThetaOut, make_complex(etaSpec[int(i)],kSpec[int(i)]));
    val[int(i)] = (cosThetaOut <= 1e-6f) ? 0.0f : (val[int(i)] / max(cosThetaOut, 1e-6f));  
  }
  
  pRes.val = val; 
  pRes.dir = dir;
  pRes.pdf = pdf;
  pRes.flags = RAY_EVENT_S;
}

void conductorRoughSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfSample pRes) {
  if(v.z == 0)
    return;

  // const uint cflags = as_uint(a_materials[0].data[UINT_CFLAGS]);


  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_U], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_V], alpha_tex.y));

  vec3 nx,  ny, nz = n;
  CoordinateSystemV2(nz, nx, ny);
  const vec3 wo = vec3(dot(v, nx),dot(v, ny),dot(v, nz));
  if(wo.z == 0)
    return;

  if(wo.z == 0)
    return;

  vec3 wm = trSample(wo, vec2(rands.x,rands.y), alpha);
  vec3 wi = reflect((-1.0f) * wo, wm);

  if(wo.z * wi.z < 0) // not in the same hemisphere
  {
    return;
  }

  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = conductorRoughEvalInternal(wo, wi, wm, alpha, make_complex(etaSpec[int(i)],kSpec[int(i)]));
  }

  pRes.val   = val; 
  pRes.dir   = normalize(wi.x * nx + wi.y * ny + wi.z * nz);
  pRes.pdf   = trPDF(wo, wm, alpha) / (4.0f * abs(dot(wo, wm)));
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
}

vec3 BumpMapping(uint normalMapId, uint currMatId, vec3 n, vec3 tan, vec2 tc) {
  const uint   mflags    = floatBitsToUint(m_materials[currMatId].data[UINT_CFLAGS]);
  const vec2 texCoordT = mulRows2x4(m_materials[currMatId].row0[1], m_materials[currMatId].row1[1], tc);
  const vec4 normalTex = texture(m_textures[normalMapId], texCoordT);
  const vec3 normalTS = NormalMapTransform(mflags, normalTex.xyz);
  
  const vec3 bitan = cross(n, tan);
  const mat3 tangentTransform = make_float3x3(tan, bitan, n);

  return normalize(inverse(tangentTransform)*normalTS);
}

uint MaterialBlendSampleAndEval(uint a_materialId, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec2 tc, inout MisData a_misPrev, inout BsdfSample a_pRes) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const uint   texId     = floatBitsToUint(m_materials[a_materialId].data[BLEND_TEXID0]);
  const vec4 weightDat = texture(m_textures[texId], texCoordT);
  const float  weightTex = weightDat.x;
  const float  weight    = m_materials[a_materialId].data[BLEND_WEIGHT] * weightTex;

  const uint matId1 = floatBitsToUint(m_materials[a_materialId].data[BLEND_MAT_ID_1]);
  const uint matId2 = floatBitsToUint(m_materials[a_materialId].data[BLEND_MAT_ID_2]);

  uint selectedMatId = matId1;
  const float select = rndFloat1_Pseudo(a_gen);
  if(select < weight)
  {
    a_pRes.pdf *= weight;
    a_pRes.val *= weight;
    selectedMatId = matId2;
  }
  else
  {
    a_pRes.pdf *= 1.0f - weight;
    a_pRes.val *= 1.0f - weight;
    selectedMatId = matId1;
  }

  return selectedMatId;
}

vec4 SampleMatParamSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId) {  
  vec4 res = vec4(m_materials[matId].data[paramId]);
  if(a_wavelengths[0] == 0.0f)
    return res;

  const uint specId = floatBitsToUint(m_materials[matId].data[paramSpecId]);

  if(specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    res = SampleSpectrum_m_wavelengths_m_spec_values(offset, offset, a_wavelengths, size);
  }

  return res;
}

MatIdWeightPair MaterialBlendEval(MatIdWeight a_mat, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_mat.id].row0[0], m_materials[a_mat.id].row1[0], tc);
  const uint   texId     = floatBitsToUint(m_materials[a_mat.id].data[BLEND_TEXID0]);
  const vec4 weightDat = texture(m_textures[texId], texCoordT);
  const float  weightTex = weightDat.x;
  const float  weight    = m_materials[a_mat.id].data[BLEND_WEIGHT] * weightTex;

  const uint matId1      = floatBitsToUint(m_materials[a_mat.id].data[BLEND_MAT_ID_1]);
  const uint matId2      = floatBitsToUint(m_materials[a_mat.id].data[BLEND_MAT_ID_2]);

  MatIdWeight p1, p2;
  p1.id     = matId1;
  p1.weight = a_mat.weight * (1.0f - weight);
  p2.id     = matId2;
  p2.weight = a_mat.weight * weight;

  return make_weight_pair(p1, p2);
}

vec4 SampleMatColorParamSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId) {  
  vec4 res = m_materials[matId].colors[paramId];
  if(a_wavelengths[0] == 0.0f)
    return res;

  const uint specId = floatBitsToUint(m_materials[matId].data[paramSpecId]);

  if(specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    res = SampleSpectrum_m_wavelengths_m_spec_values(offset, offset, a_wavelengths, size);
  }

  return res;
}

float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, const vec3 lpos, const vec3 lnorm) {
  const uint gtype    = m_lights[a_lightId].geomType;
  const float hitDist = length(illuminationPoint - lpos);
  
  float cosVal = 1.0f;
  switch(gtype)
  {
    case LIGHT_GEOM_SPHERE:
    {
      // const float  lradius = m_lights[a_lightId].size.x;
      // const float3 lcenter = to_float3(m_lights[a_lightId].pos);
      //if (DistanceSquared(illuminationPoint, lcenter) - lradius*lradius <= 0.0f)
      //  return 1.0f;
      const vec3 dirToV = normalize(lpos - illuminationPoint);
      cosVal = abs(dot(dirToV, lnorm));
    }
    break;

    case LIGHT_GEOM_POINT:
    {
      if(m_lights[a_lightId].distType == LIGHT_DIST_OMNI)
        cosVal = 1.0f;
      else
        cosVal = max(dot(ray_dir, -1.0f*lnorm), 0.0f);
    };
    break;

    default:
    cosVal  = max(dot(ray_dir, -1.0f*lnorm), 0.0f);
    break;
  };
  
  return PdfAtoW(m_lights[a_lightId].pdfA, hitDist, cosVal);
}

bool isOutOfScene(uint a_flags) { return (a_flags & RAY_FLAG_OUT_OF_SCENE)   != 0; }

vec4 GetEnvironmentColorAndPdf(vec3 a_dir) {
  return ubo.m_envColor;
}

LightSample LightSampleRev(int a_lightId, vec2 rands, vec3 illiminationPoint) {
  const uint gtype = m_lights[a_lightId].geomType;
  switch(gtype)
  {
    case LIGHT_GEOM_DIRECT: return directLightSampleRev_m_lights(a_lightId, rands, illiminationPoint);
    case LIGHT_GEOM_SPHERE: return sphereLightSampleRev_m_lights(a_lightId, rands);
    case LIGHT_GEOM_POINT:  return pointLightSampleRev_m_lights(a_lightId);
    default:                return areaLightSampleRev_m_lights(a_lightId, rands);
  };
}

vec3 MaterialEvalWhitted(uint a_materialId, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const uint   texId     = floatBitsToUint(m_materials[a_materialId].data[GLTF_UINT_TEXID0]);
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[texId], texCoordT)).xyz;
  const vec3 color = m_materials[a_materialId].colors[GLTF_COLOR_BASE].xyz*texColor;
  return lambertEvalBSDF(l, v, n)*color;
}

float LightPdfSelectRev(int a_lightId) { 
  return 1.0f/float(ubo.m_lights_size); // uniform select
}

uint extractMatId(uint a_flags) { return (a_flags & 0x00FFFFFF); }

BsdfSample MaterialSampleAndEval(uint a_materialId, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec3 tan, vec2 tc, inout MisData a_misPrev, const uint a_currRayFlags) {
  BsdfSample res;
  {
    res.val   = vec4(0,0,0,0);
    res.pdf   = 1.0f;
    res.dir   = vec3(0,1,0);
    res.flags = a_currRayFlags;
  }

  uint currMatId = a_materialId;
  uint     mtype     = floatBitsToUint(m_materials[currMatId].data[UINT_MTYPE]);
  while(KSPEC_MAT_TYPE_BLEND != 0 && mtype == MAT_TYPE_BLEND)
  {
    currMatId = MaterialBlendSampleAndEval(currMatId, wavelengths, a_gen, v, n, tc, a_misPrev, res);
    mtype     = floatBitsToUint(m_materials[currMatId].data[UINT_MTYPE]);
  }
  
  // BSDF is multiplied (outside) by cosThetaOut1.
  // When normal map is enables this becames wrong because normal is changed;
  // First : return cosThetaOut in sam;
  // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
  //
  const uint normalMapId   = floatBitsToUint(m_materials[currMatId].data[UINT_NMAP_ID]);
  const vec3 geomNormal = n;
        vec3 shadeNormal = n;

  if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF)
    shadeNormal = BumpMapping(normalMapId, currMatId, geomNormal, tan, tc);

  const vec2 texCoordT = mulRows2x4(m_materials[currMatId].row0[0], m_materials[currMatId].row1[0], tc);
  const vec4 rands = rndFloat4_Pseudo(a_gen);

  switch(mtype)
  {
    case MAT_TYPE_GLTF:
    if(KSPEC_MAT_TYPE_GLTF != 0)
    {
      const uint   texId    = floatBitsToUint(m_materials[currMatId].data[GLTF_UINT_TEXID0]);
      const vec4 texColor = texture(m_textures[texId], texCoordT);
      const vec4 color = m_materials[currMatId].colors[GLTF_COLOR_BASE]*texColor;
      gltfSampleAndEval_m_materials(currMatId, rands, v, shadeNormal, tc, color, res);
    }
    break;
    case MAT_TYPE_GLASS: 
    if(KSPEC_MAT_TYPE_GLASS != 0)
    {
      glassSampleAndEval_m_materials(currMatId, rands, v, geomNormal, tc, res, a_misPrev);
    }
    break;
    case MAT_TYPE_CONDUCTOR:
    if(KSPEC_MAT_TYPE_CONDUCTOR != 0)
    {
      const uint   texId     = floatBitsToUint(m_materials[currMatId].data[CONDUCTOR_TEXID0]);
      const vec3 alphaTex = (texture(m_textures[texId], texCoordT)).xyz;
      
      const vec2 alpha = vec2(m_materials[currMatId].data[CONDUCTOR_ROUGH_V],m_materials[currMatId].data[CONDUCTOR_ROUGH_U]);
      const vec4 etaSpec = SampleMatParamSpectrum(currMatId, wavelengths, CONDUCTOR_ETA, CONDUCTOR_ETA_SPECID);
      const vec4 kSpec = SampleMatParamSpectrum(currMatId, wavelengths, CONDUCTOR_K, CONDUCTOR_K_SPECID);
      if(trEffectivelySmooth(alpha))
        conductorSmoothSampleAndEval_m_materials(currMatId, etaSpec, kSpec, rands, v, shadeNormal, tc, res);
      else
        conductorRoughSampleAndEval_m_materials(currMatId, etaSpec, kSpec, rands, v, shadeNormal, tc, alphaTex, res);
    }
    break;
    case MAT_TYPE_DIFFUSE:
    if(KSPEC_MAT_TYPE_DIFFUSE != 0)
    {
      const uint   texId       = floatBitsToUint(m_materials[currMatId].data[DIFFUSE_TEXID0]);
      const vec4 texColor = texture(m_textures[texId], texCoordT);
      const vec4 color = texColor;
      const vec4 reflSpec = SampleMatColorParamSpectrum(currMatId, wavelengths, DIFFUSE_COLOR, DIFFUSE_SPECID);

      diffuseSampleAndEval_m_materials(currMatId, reflSpec, rands, v, shadeNormal, tc, color, res);
    }
    break;
    case MAT_TYPE_PLASTIC:
    if(KSPEC_MAT_TYPE_PLASTIC != 0)
    {
      const uint   texId       = floatBitsToUint(m_materials[currMatId].data[PLASTIC_COLOR_TEXID]);
      const vec4 texColor = (texture(m_textures[texId], texCoordT));
      const vec4 color = texColor;

      vec4 reflSpec = SampleMatColorParamSpectrum(currMatId, wavelengths, PLASTIC_COLOR, PLASTIC_COLOR_SPECID);
      if(ubo.m_spectral_mode == 0)
        reflSpec *= color;

      const uint precomp_id = floatBitsToUint(m_materials[currMatId].data[PLASTIC_PRECOMP_ID]);

      plasticSampleAndEval_m_materials_m_precomp_coat_transmittance(currMatId, reflSpec, rands, v, shadeNormal, tc, res, precomp_id * MI_ROUGH_TRANSMITTANCE_RES);
    }
    break;
    default:
    break;
  }
  
  // BSDF is multiplied (outside) by cosThetaOut1.
  // When normal map is enables this becames wrong because normal is changed;
  // First : return cosThetaOut in sam;
  // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
  //
  if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF)
  {
    const float cosThetaOut1 = abs(dot(res.dir, geomNormal));
    const float cosThetaOut2 = abs(dot(res.dir, shadeNormal));
    res.val *= cosThetaOut2 / max(cosThetaOut1, 1e-10f);
  }

  return res;
}

bool hasNonSpecular(uint a_flags) { return (a_flags & RAY_FLAG_HAS_NON_SPEC)   != 0; }

bool isDeadRay(uint a_flags) { return (a_flags & RAY_FLAG_IS_DEAD)        != 0; }

uint packMatId(uint a_flags, uint a_matId) { return (a_flags & 0xFF000000) | (a_matId & 0x00FFFFFF); }

uint RemapMaterialId(uint a_mId, int a_instId) {
  const int remapListId  = m_remapInst[a_instId];
  if(remapListId == -1)
    return a_mId;

  const int r_offset     = m_allRemapListsOffsets[remapListId];
  const int r_size       = m_allRemapListsOffsets[remapListId+1] - r_offset;
  const ivec2 offsAndSize = ivec2(r_offset,r_size);
  
  uint res = a_mId;
  
  // for (int i = 0; i < offsAndSize.y; i++) // linear search version
  // {
  //   int idRemapFrom = m_allRemapLists[offsAndSize.x + i * 2 + 0];
  //   int idRemapTo   = m_allRemapLists[offsAndSize.x + i * 2 + 1];
  //   if (idRemapFrom == a_mId) {
  //     res = idRemapTo;
  //     break;
  //   }
  // }

  int low  = 0;
  int high = offsAndSize.y - 1;              // binary search version
  
  while (low <= high)
  {
    const int mid         = low + ((high - low) / 2);
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + mid * 2 + 0];
    if (uint(idRemapFrom) >= a_mId)
      high = mid - 1;
    else //if(a[mid]<i)
      low = mid + 1;
  }

  if (high+1 < offsAndSize.y)
  {
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 0];
    const int idRemapTo   = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 1];
    res                   = (uint(idRemapFrom) == a_mId) ? uint(idRemapTo) : a_mId;
  }

  return res;
}

vec4 GetLightSourceIntensity(uint a_lightId, in vec4 a_wavelengths) {
  vec4 lightColor = m_lights[a_lightId].intensity;  
  if(KSPEC_SPECTRAL_RENDERING !=0 && ubo.m_spectral_mode != 0)
  {
    const uint specId = m_lights[a_lightId].specId;
  
    if(specId < 0xFFFFFFFF)
    {
      // lightColor = SampleSpectrum(m_spectra.data() + specId, *a_wavelengths);
      const uvec2 data = m_spec_offset_sz[specId];
      const uint offset = data.x;
      const uint size   = data.y;
      lightColor = SampleSpectrum_m_wavelengths_m_spec_values(offset, offset, a_wavelengths, size);
    }
  }
  lightColor *= m_lights[a_lightId].mult;
  return lightColor;
}

BsdfEval MaterialEval(uint a_materialId, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec3 tan, vec2 tc) {
  BsdfEval res;
  {
    res.val = vec4(0,0,0,0);
    res.pdf   = 0.0f;
  }

  MatIdWeight currMat = make_id_weight(a_materialId, 1.0f);
  MatIdWeight material_stack[KSPEC_BLEND_STACK_SIZE];
  if(KSPEC_MAT_TYPE_BLEND != 0)
    material_stack[0] = currMat;
  int top = 0;
  bool needPop = false;

  do
  {
    if(KSPEC_MAT_TYPE_BLEND != 0)
    {
      if(needPop)
      {
        top--;
        currMat = material_stack[max(top, 0)];
      }
      else
        needPop = true; // if not blend, pop on next iter
    } 
    
    // BSDF is multiplied (outside) by old cosThetaOut.
    // When normal map is enables this becames wrong because normal is changed;
    // First : return cosThetaOut in sam;
    // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
    //
    const vec3 geomNormal = n;
          vec3 shadeNormal = n;
    float bumpCosMult = 1.0f; 
    const uint normalMapId = floatBitsToUint(m_materials[currMat.id].data[UINT_NMAP_ID]);
    if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF) 
    {
      shadeNormal = BumpMapping(normalMapId, currMat.id, geomNormal, tan, tc);
      const vec3 lDir = l;     
      const float  clampVal = 1e-6f;  
      const float cosThetaOut1 = max(dot(lDir, geomNormal), 0.0f);
      const float cosThetaOut2 = max(dot(lDir, shadeNormal), 0.0f);
      bumpCosMult              = cosThetaOut2 / max(cosThetaOut1, clampVal);
      if (cosThetaOut1 <= 0.0f)
        bumpCosMult = 0.0f;
    }

    const vec2 texCoordT = mulRows2x4(m_materials[currMat.id].row0[0], m_materials[currMat.id].row1[0], tc);
    const uint   mtype     = floatBitsToUint(m_materials[currMat.id].data[UINT_MTYPE]);

    BsdfEval currVal;
    {
      currVal.val = vec4(0,0,0,0);
      currVal.pdf   = 0.0f;
    }
    switch(mtype)
    {
      case MAT_TYPE_GLTF:
      if(KSPEC_MAT_TYPE_GLTF != 0)
      {
        const uint   texId     = floatBitsToUint(m_materials[currMat.id].data[GLTF_UINT_TEXID0]);
        const vec4 texColor = texture(m_textures[texId], texCoordT);
        const vec4 color = (m_materials[currMat.id].colors[GLTF_COLOR_BASE]) * texColor;
        gltfEval_m_materials(currMat.id, l, v, shadeNormal, tc, color, currVal);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;

        break;
      }
      case MAT_TYPE_GLASS:
      if(KSPEC_MAT_TYPE_GLASS != 0)
      {
        glassEval_m_materials(currMat.id, l, v, geomNormal, tc, vec3(0,0,0), currVal);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
        break;
      }
      case MAT_TYPE_CONDUCTOR: 
      if(KSPEC_MAT_TYPE_CONDUCTOR != 0)
      {
        const uint   texId     = floatBitsToUint(m_materials[currMat.id].data[CONDUCTOR_TEXID0]);
        const vec3 alphaTex = (texture(m_textures[texId], texCoordT)).xyz;
        const vec2 alpha = vec2(m_materials[currMat.id].data[CONDUCTOR_ROUGH_V],m_materials[currMat.id].data[CONDUCTOR_ROUGH_U]);

        if(!trEffectivelySmooth(alpha))
        {
          const vec4 etaSpec = SampleMatParamSpectrum(currMat.id, wavelengths, CONDUCTOR_ETA, CONDUCTOR_ETA_SPECID);
          const vec4 kSpec = SampleMatParamSpectrum(currMat.id, wavelengths, CONDUCTOR_K, CONDUCTOR_K_SPECID);
          conductorRoughEval_m_materials(currMat.id, etaSpec, kSpec, l, v, shadeNormal, tc, alphaTex, currVal);
        }

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
        break;
      }
      case MAT_TYPE_DIFFUSE:
      if(KSPEC_MAT_TYPE_DIFFUSE != 0)
      {
        const uint   texId       = floatBitsToUint(m_materials[currMat.id].data[DIFFUSE_TEXID0]);
        const vec4 texColor = (texture(m_textures[texId], texCoordT));
        const vec4 color = texColor;

        const vec4 reflSpec = SampleMatColorParamSpectrum(currMat.id, wavelengths, DIFFUSE_COLOR, DIFFUSE_SPECID);

        diffuseEval_m_materials(currMat.id, reflSpec, l, v, shadeNormal, tc, color, currVal);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
        break;
      }
      case MAT_TYPE_PLASTIC:
      if(KSPEC_MAT_TYPE_PLASTIC != 0)
      {
        const uint   texId       = floatBitsToUint(m_materials[currMat.id].data[PLASTIC_COLOR_TEXID]);
        const vec4 texColor = (texture(m_textures[texId], texCoordT));
        const vec4 color = texColor;

        vec4 reflSpec = SampleMatColorParamSpectrum(currMat.id, wavelengths, PLASTIC_COLOR, PLASTIC_COLOR_SPECID);
        if(ubo.m_spectral_mode == 0)
          reflSpec *= color;
        const uint precomp_id = floatBitsToUint(m_materials[currMat.id].data[PLASTIC_PRECOMP_ID]);
        plasticEval_m_materials_m_precomp_coat_transmittance(currMat.id, reflSpec, l, v, shadeNormal, tc, currVal, precomp_id * MI_ROUGH_TRANSMITTANCE_RES);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
        break;
        break;
      }
      case MAT_TYPE_BLEND:
      if(KSPEC_MAT_TYPE_BLEND != 0)
      {
        MatIdWeightPair childMats = MaterialBlendEval(currMat, wavelengths, l, v, geomNormal, tc);
        currMat = childMats.first;
        needPop = false;                        // we already put 'childMats.first' in 'currMat'
        if(top + 1 <= KSPEC_BLEND_STACK_SIZE)
        {
          material_stack[top] = childMats.second; // remember second mat in stack
          top++;
        }
        break;
      }
      default:
        break;
    }

  } while(KSPEC_MAT_TYPE_BLEND != 0 && top > 0);

  return res;
}

BsdfSample MaterialSampleWhitted(uint a_materialId, vec3 v, vec3 n, vec2 tc) { 
  // const uint  type       = as_uint(m_materials[a_materialId].data[UINT_MTYPE]);
  const vec4 specular = (m_materials[a_materialId].colors[GLTF_COLOR_METAL]);
  const vec4 coat = (m_materials[a_materialId].colors[GLTF_COLOR_COAT]);
  // const float  roughness = 1.0f - m_materials[a_materialId].data[GLTF_FLOAT_GLOSINESS];
  float alpha            = m_materials[a_materialId].data[GLTF_FLOAT_ALPHA];
  
  const vec3 pefReflDir = reflect((-1.0f)*v, n);
  const vec4 reflColor = alpha*specular + (1.0f - alpha)*coat;

  //if(a_materialId == 4)
  //{
  //  int a = 2;
  //}

  BsdfSample res;
  res.dir   = pefReflDir;
  res.val   = reflColor;
  res.pdf   = 1.0f;
  res.flags = RAY_EVENT_S;
  return res;
}

// RayScene intersection with 'm_pAccelStruct'
//
CRT_Hit m_pAccelStruct_RayQuery_NearestHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsOpaqueEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  
  while(rayQueryProceedEXT(rayQuery)) { } // actually may omit 'while' when 'gl_RayFlagsOpaqueEXT' is used
 
  CRT_Hit res;
  res.primId = -1;
  res.instId = -1;
  res.geomId = -1;
  res.t      = rayDir.w;

  if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
  {    
	  res.primId    = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	  res.geomId    = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
    res.instId    = rayQueryGetIntersectionInstanceIdEXT    (rayQuery, true);
	  res.t         = rayQueryGetIntersectionTEXT(rayQuery, true);
    vec2 bars     = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
    
    res.coords[0] = bars.y;
    res.coords[1] = bars.x;
    res.coords[2] = 1.0f - bars.y - bars.x;
  }

  return res;
}

bool m_pAccelStruct_RayQuery_AnyHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  rayQueryProceedEXT(rayQuery);
  return (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_GetRayColor_m_packedXY_out_color(uint tid, in Lite_Hit in_hit, uint in_pakedXYOffset, uint out_colorOffset) 
{
   
  if(tid >= ubo.m_maxThreadId)
    return;

  const Lite_Hit lhit = in_hit;
  if(lhit.geomId == -1)
  {
    out_color[tid + out_colorOffset] = 0;
    return;
  }

  const uint matId = m_matIdByPrimId[m_matIdOffsets[lhit.geomId] + uint(lhit.primId)];
  const vec4 mdata = m_materials[matId].colors[GLTF_COLOR_BASE];
  const vec3 color = mdata.w > 0.0f ? clamp(vec3(mdata.w,mdata.w,mdata.w), 0.0f, 1.0f) : mdata.xyz;

  const uint XY = m_packedXY[tid + in_pakedXYOffset];
  const uint x  = (XY & 0x0000FFFF);
  const uint y  = (XY & 0xFFFF0000) >> 16;

  out_color[y*uint(ubo.m_winWidth)+x + out_colorOffset] = RealColorToUint32_f3(color); 

}

void kernel_InitEyeRay_m_packedXY(uint tid, uint packedXYOffset, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  const uint XY = m_packedXY[tid + packedXYOffset];

  const uint x = (XY & 0x0000FFFF);
  const uint y = (XY & 0xFFFF0000) >> 16;

  vec3 rayDir = EyeRayDirNormalized((float(x)+0.5f)/float(ubo.m_winWidth), (float(y)+0.5f)/float(ubo.m_winHeight), ubo.m_projInv);
  vec3 rayPos = vec3(0,0,0);

  transform_ray3f(ubo.m_worldViewInv, 
                  rayPos, rayDir);
  
  rayPosAndNear = vec4(rayPos, 0.0f);
  rayDirAndFar  = vec4(rayDir, FLT_MAX);

}

bool kernel_RayTrace(uint tid, in vec4 rayPosAndNear, inout vec4 rayDirAndFar, inout Lite_Hit out_hit, inout vec2 out_bars) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return false;
  const vec4 rayPos = rayPosAndNear;
  const vec4 rayDir = rayDirAndFar ;

  CRT_Hit hit = m_pAccelStruct_RayQuery_NearestHit(rayPos, rayDir);
  
  Lite_Hit res;
  res.primId = int(hit.primId);
  res.instId = int(hit.instId);
  res.geomId = int(hit.geomId);
  res.t      = hit.t;

  vec2 baricentrics = vec2(hit.coords[0],hit.coords[1]);
 
  out_hit  = res;
  out_bars = baricentrics;
  return (res.primId != -1);

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tid = uint(gl_GlobalInvocationID[0]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  vec4 rayPosAndNear,  rayDirAndFar;
  kernel_InitEyeRay_m_packedXY(tid, 0, rayPosAndNear, rayDirAndFar);

  Lite_Hit hit; 
  vec2 baricentrics; 
  if(!kernel_RayTrace(tid, rayPosAndNear, rayDirAndFar, hit, baricentrics))
    return;
  
  kernel_GetRayColor_m_packedXY_out_color(tid, hit, 0, 0);

}

